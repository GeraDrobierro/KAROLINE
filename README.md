### KAROLINE

# ВСТУПЛЕНИЕ
Вся моя работа над вопросно-ответной системой 'KAROLINE' началась с комадны `say`, введеной в терминал, которая заставила мой компьютер возпроизвести последующую за ней строку `Hello my friend`

Далее в python, я написал простенький код, чтобы проверить одну теорию:

```
import os
a = str(input())
If a == “привет”
print(os.system(‘say ‘ + ‘привет, меня зовут Каролина’))
```

И вот оно. В первый раз заговорили с женским полом, шучу. Этот код позволил убедиться в следующей теории. Я ввёл некую ключевую команду строчного типа, а потом сделал так, чтобы на этот ключ реагировала наша программа, и это сработало. Из всего этого следует, что я могу задать n-количество ключевых команд, и Каролина будет на них реагировать.

Но мы хотим, чтобы она сумела не только говорить с нами, мы хотим, чтобы она нас слушала, выполняла различные команды. И таким образом, я плавно перехожу к следующему пункту, а именно оставлению блок-схемы или roadmap Каролины.

# ROADMAP

![здесь должна быть  roadmap, но разработчик ушел кушать](https://github.com/GeraDrobierro/KAROLINE/files/12868733/ROADMAP.pdf)


В каждом блоке или квадратике, как вам угодно, написана задача, которую должна выполнять Каролина. С помощью лучшего изобретения человечества(интернет) и некоторых знаний, стрелочками вне блоков я написал решение этих задача.

## БИБЛИОТЕКИ
Из поставленных в roadmap задач для того, чтобы создать мою Каролину мне нужно было что-то, что могло бы слышать мою речь и переводить ее в строку. Для этого, благо, на Python существует библиотека Speech_Recognition. Обо всем ее функционале в полном объёме объясняют [здесь](https://pythonpip.ru/examples/raspoznavanie-rechi-i-golosa-na-python-podrobno#:~:text=Библиотека%20SpeechRecognition%20ведет%20себя%20как,заданное%20распознавание%20речи%20по%20умолчанию.). Мне же нужно было только то, что с помощью этой библиотеки можно записывать речь с микрофона и преобразовать ее в  строчный формат. Далее, модуль [webbrowser](https://docs.python.org/3/library/webbrowser.html), он позволит работать с url ссылками и открывать их. 
Библиотека [AppOpener](https://pypi.org/project/appopener/), данная библиотека позволит работать с приложениями, установленными на моем компьютере. Модуль [sys](https://pythonim.ru/moduli/sys-python) нужен будет в будущем для того, чтобы остановить работу Каролины по ключевому слову. Сейчас самый важный модуль - os. Проследите за логической цепочкой: say является одной из команд операционной системы, python просто так с ним работать не будет, он попросту не понимает что такое say, поэтому нам нужно что-то, что позволяло бы работать с этой командой, и решением этого вопроса станет библиотека [os](https://all-python.ru/osnovy/os.html#chto-takoe-modul-os).

## УСТАНОВКА НЕОБХОДИМЫХ БИИБЛИОТЕК

Чтобы скачать библиотеки, надо открыть терминал компьютера и в нем написать

```
pip install SpeechRecongnition
pip install AppOpener

```
os, sys, webbrowser - являются установленными по умолчанию библиотеками.

# КОД

Сначала импортируем необходимый нам библиотеки, чтобы мы могли с ними работать
```
import speech_recognition
import os
import sys
import webbrowser
from AppOpener import open
```

## ФУНКЦИИ

Так, теперь, постоянно прописывать `os.system(‘say ‘ + ‘текст’)` неудобно, долго, муторно и другие негативные прилагательные. Cоздадим функцию, с помощью которой будет говорить Каролина

```
def talk(words):
    print(words)
    os.system("say " + words)
```
Обьяснение кода я передаю своему коллеге, ![proggramist](https://github.com/GeraDrobierro/KAROLINE/files/12893271/CamScanner.13.10.2023.15.04.pdf)

Теперь вы знакомы с понятием функци и мы можем рассмотреть другие функции, которые я добавил в код, и их возможности.

```
def KarolineClosework():
    return talk("Отключаюсь, приятно было поработать"), sys.exit()
```
При вызове этой функции наша Каролина скажет пока, и с помощью модуля sys, а именно ее функции sys.exit(), которая прекращает процесс выполнения нашего кода, завершит выполнение Каролины.

```
def KarolineHello():
    return talk("Здравствуйте")
```
При вызове этой функции Каролина поздаровается с нами, поэтому это можно назвать привественной функцией.

```
def KarolineOpenApp():
    return talk("Открываю " + query)
```
При вызове этой функции, когда нам понадобиться открыть приложение на компьютере, Каролина произнесет слова открываю и название приложения, которое мы попросили ее открыть.

## ХЕШ-ТАБЛИЦА
Что это и зачем оно нужно ?
Хеш-таблица - это структура данных, которая принимает ключ и передаёт нам значение. Ключ - один, а значений может быть много. Очень удобная вещь в умелых руках. Подробнее о ней рассказал Адитья Бхаргава в своей книге [«Грокаем Алгоритмы».](https://www.klex.ru/1718) Но зачем она мне здесь ? Видите ли, мы с вами говорим по разному, и слово «привет», к примеру, можно сказать как приветус, приветик, приветули. А Каролина должна понимать все эти значения, поэтому хеш таблица, выручит нас в этом. Мы передадим Каролине ключ [‘hello’], и если в значениях по этому ключу будет содержаться какой-либо вариант из выше перечисленного, она поймёт нас и выполнит команду, как только распознаёт это значение в хеш-таблице.

```
graph = {}
graph['интернет'] = ['web', 'map', 'инет', 'паутина']
graph['allMAcBookAppsEng'] = ['открой skype', 'откройка steam', 'open skype', 'open steam']
graph['Karolineworkoff'] = ['закройся', 'stop', 'exit', 'пока', 'bye', 'off', 'стоп']
graph['KarolineMusic'] = ['music', 'музыка', 'melody', 'мелодия']
graph['clock'] = ['clock', 'time', 'alarm', 'покажи время', 'минуты', 'секунды']
graph['программа'] = ['https://www.youtube.com/watch?v=SW_UCzFO7X0', 'часы']
allMAcBookAppsEng = ['skype', 'steam', 'zoom', 'freeform', 'discord', 'google chrome', 'miro', 'tv', 'blender']
```


Если говорить честно, я экспериментировал в хеш-таблице, поэтому в ней реализовано не только разное произношение слов, к примеру, я добавил сюда ключ graph['allMAcBookAppsEng'], чтобы посмотреть сможет ли Каролина распознавать не только команды из одного слова, но и из нескольких, как выяснилось, она может это делать.

Далее я добавил массив, который можно было бы занести в хеш, но я этого не сделал, опять же из за экспериментов с Каролиной. (Прикольно, что теперь я могу оправдать что угодно в коде, сказав, что это был эксперимент ;))

```
allMAcBookAppsEng = ['skype', 'steam', 'zoom', 'freeform', 'discord', 'google chrome', 'miro', 'tv', 'blender']
```

Это все программы моего компьютера на английском языке, чтобы в будущем Каролина проверяла, есть ли такая программа на компьютере, и открывала ее в случае нахождения. С этой частью когда разобрались, идём дальше.

## ОСНОВНОЙ БЛОК КОДА. КОНСТРУКЦИЯ try-except.
Сейчас мы будем разбираться в следующем блоке кода:

```
with speech_recognition.Microphone() as mic:
    print('Говорите')
    sr.pause_threshold = 1
    sr.adjust_for_ambient_noise(source=mic, duration=1)
    audio = sr.listen(source=mic)
    try:
        query = sr.recognize_google(audio, language='ru').lower()
        print('вы сказали:' + query)
    except speech_recognition.UnknownValueError:
        print('(\(\ ')
        print('(=0:0)')
        print( '(..(")(")')
```

1. `with speech_recognition.Microphone() as mic:` - начинаем прослушивать микрофон. 
Добавляем строку `print(«Говорите»)`, чтобы пользователь понимал, когда Каролина слушает его.

2. `sr.pause_threshold = 1` - здесь мы установили паузы, после которой Каролина будет нас слушать.


Пример:

Каролина >> Говорите

**1 секунда проходит**

Пользователь >> Говорит

Каролина >> Выполняет команду

`sr.adjust_for_ambient_noise(source=mic, duration=1)` - убираем посторонние шумы из аудиодорожки, чтобы Каролина ‘концентрировалась’ на нашем голосе и командах.

`audio = sr.listen(source=mic)` - передаем наши записанные данные в переменную **audio**.

3. Теперь самая важная часть кода, без которой ничего не будет работать.
```
   try:
        query = sr.recognize_google(audio, language='ru').lower()
        print('вы сказали:' + query)
    except speech_recognition.UnknownValueError:
        print('(\(\ ')
        print('(=0:0)')
        print( '(..(")(")')
```
Сначала опишу, что происходит внутри кода:
Переменная query распознает данные, которые были записаны в переменную audio, так как по умолчанию распознавание на английском, мы добавили распознавание на русском и еще добавили нижний регистр с помощью .lower() (это - нижний регистр, ЭТО - не нижний регистр).

Потом с помощью `print('вы сказали:' + query)` будет выводиться то, что мы сказали. Но проблема в том, что у распознавания речи есть одна ошибка, которая прекращает работу алгоритма в случае ее возникновения. Это ошибка UnknownValueError - означает, что Каролина не поняла, что мы ей сказали. Это был один из самых важных врагов моего кода. На помощь мне пришла особая конструкция, о которой говорится ниже.

Теперь я расскажу про конструкцию  **try - except**:

Напишите пожалуйста следующий код:
```
print(7/0)

>> ZeroDivisionError: division by zero
```
И что же мы получили ? Ошибку (ZeroDivisionError: division by zero), ведь на ноль делить нельзя, но что, если скажу, что мы можем сделать это не ошибкой.

```
try:
    print(7/0)
except ZeroDivisionError:
    print('ты математически накосячил, но ничего страшного')
```
Теперь вместо `‘ZeroDivisionError: division by zero’`, мы получаем `'ты математически накосячил, но ничего страшного’`. Подробно посмотрим, что произошло:

Я попросил компьютер, чтобы он пытался выполнить print(7/0), но при этом ожидал ошибку ZeroDivisionError и выводил ‘ты математически накосячил, но ничего страшного’. На языке программирования Python в try: мы пишем, что хотим сделать, а в except <название ошибки> : действия в случае этой ошибки.

Вернемся к нашему основному коду.
```
   try:
        query = sr.recognize_google(audio, language='ru').lower()
        print('вы сказали:' + query)
    except speech_recognition.UnknownValueError:
        print('(\(\ ')
        print('(=0:0)')
        print( '(..(")(")')
```
Мы передали в **try:**

  **query = sr.recognize_google(audio, language='ru').lower()**
  
   **print('вы сказали:' + query)**
   
То есть попросили Каролину, чтобы она распознавала наш голос, но в случае ошибки , попросили ее быть к ней готовой и выводили зайчика:

 **except speech_recognition.UnknownValueError:**
 
 **print('(\(\ ‘)**
 
 **print('(=0:0)’)**
 
 **print( ‘(..(")(")’)**

Для тех, кто хочет ознакомиться с этой констрикцией `try-except` подробней, нажмите на [меня](https://www.youtube.com/watch?v=qjqbek5tG3A&t=643s).

Итак, мы добавили возможность Каролины распознавать наши ключевые слова и выводить их на 
терминале. Теперь привяжем к нашем ключевым словам действия, которые будет совершать Каролина при распознавании наших ключевых слов.

```
 if 'try' in query:
            talk('Отлично')
        elif query == 'hello':
            print(KarolineHello())
        elif query in allMAcBookAppsEng or query in graph['allMAcBookAppsEng']:
            print(KarolineOpenApp())
            open(query)
        elif query in graph['интернет']:
            talk('Начинаем серфить интернет')
            url = 'https://www.google.com/?client=safari&channel=iphone_bm'
            webbrowser.open(url)
        elif query in graph['clock']:
            talk('Время не любит, когда его убивают' + query)
            url = 'https://time100.ru/Saint-Petersburg'
            webbrowser.open(url)
        elif query in graph['KarolineMusic']:
            talk('Открываю вашу волну')
            webbrowser.open('https://vk.com/audios371153804')
        elif query in 'сказка':
            talk("Не знаете ли вы, как мне выйти отсюда? – Это зависит от того, куда ты хочешь прийти, – ответил Кот. – Мне все равно, куда бы ни… – начала Алиса. – Значит, тебе все равно, в какую сторону идти, – перебил ее Кот. – Куда бы ни выйти, лишь бы куда-нибудь прийти, – договорила Алиса.")
        elif query in graph['Karolineworkoff']:
            print(KarolineClosework())
        elif query == 'прага':
            webbrowser.open(graph['программа'][0])
        elif query == 'калькулятор':
            a = int(input())
            b = int(input())
            print(talk(str(a+b)))

```

Спокойствие, только спокойствие. Сейчас будем разбираться, что тут написано, как только вы поймёте идею, вы поймёте весь этот огромный блок кода.


```

if 'try' in query:
            talk('Отлично')

```
Здесь мы проверяем, если в переменной query, которая хранит в себе информацию строчного типа, слово ‘try’, если ответ положительный, Каролина скажет: «Отлично». Все остальные команды, начинающиеся с elif, являются разновидностью алгоритма выше. То есть мы проверяем есть ли ключевое слово в переменной query, если ключевое слово есть, то надо выполнить действия, указанные после проверки. Так как далее все блоки аналогичны, я рассмотрю только те, которые отличаются от структуры, приведённой выше.


```
elif query in graph['интернет']:
            talk('Начинаем серфить интернет')
            url = 'https://www.google.com/?client=safari&channel=iphone_bm'
            webbrowser.open(url)
```

Здесь мы проверяем нахождение слова, которое мы сказали в хеш-таблице, и только после этого выполняем действие. В этом блоке, если я сказа какое-либо значение из хеш-таблице по ключу [‘интернет’], то с помощью webbrowser.open(url) откроется url-ссылка.

```
elif query == 'прага':
webbrowser.open(graph['программа'[0])

```

В этом блоке я проверял может ли Каролина открыть url ссылку в хеш-таблице, оказалось, что она может это сделать.


```
elif query == 'калькулятор':
            a = int(input())
            b = int(input())
            print(talk(str(a+b)))

```
Это очень интересный блок, в нем я тестировал, можно ли сделать так, чтобы Каролина воспринимала данные, введённые в терминал. Для реализации этой задумки я назвал эту команду калькулятор, потом создал две переменные - числа a,b, которые должны быть введены с терминала, а Каролина после того, как их ввели, произносила их сумму. 

В остальных блоках нет надобности объяснять, что происходит, так как вы можете сами это спокойно понять из всей информации, что я дал в этой инструкции. 

## While True
Это будет заключающий штрих на нашей картине. Нам нужно сделать так, чтобы алгоритм выполнялся до того времени, пока пользователю это нужно, поэтому мы создадим бесконечный цикл while True и внесём в него все, что было написано с момента, как Каролина подключилась к микрофону. Теперь, к вопросу о том, как Каролина поймёт, что ей пора остановится. Чтобы Каролина перестала работать нам достаточно сказать слово по хеш-таблице graph['Karolineworkoff'] = ['закройся', 'stop', 'exit', 'пока', 'bye', 'off', 'стоп']. Каролина поймёт это и выполнить следующую часть кода.

```
elif query in graph['Karolineworkoff']:
            print(KarolineClosework())
```

То есть вызовет функцию завершения всего алгоритма.

Вот код с циклом while True:

```
while True:
    with speech_recognition.Microphone() as mic:
        print('Говорите')
        sr.pause_threshold = 1
        sr.adjust_for_ambient_noise(source=mic, duration=1)
        audio = sr.listen(source=mic)
        try:
            query = sr.recognize_google(audio, language='ru').lower()
            print('вы сказали:' + query)
        except speech_recognition.UnknownValueError:
            print('(\(\ ')
            print('(=0:0)')
            print( '(..(")(")')
        if 'try' in query:
            talk('Отлично')
        elif query == 'hello':
            print(KarolineHello())
        elif query in allMAcBookAppsEng or query in graph['allMAcBookAppsEng']:
            print(KarolineOpenApp())
            open(query)
        elif query in graph['интернет']:
            talk('Начинаем серфить интернет')
            url = 'https://www.google.com/?client=safari&channel=iphone_bm'
            webbrowser.open(url)
        elif query in graph['clock']:
            talk('Время не любит, когда его убивают' + query)
            url = 'https://time100.ru/Saint-Petersburg'
            webbrowser.open(url)
        elif query in graph['KarolineMusic']:
            talk('Открываю вашу волну')
            webbrowser.open('https://vk.com/audios371153804')
        elif query in 'сказка':
            talk("Не знаете ли вы, как мне выйти отсюда? – Это зависит от того, куда ты хочешь прийти, – ответил Кот. – Мне все равно, куда бы ни… – начала Алиса. – Значит, тебе все равно, в какую сторону идти, – перебил ее Кот. – Куда бы ни выйти, лишь бы куда-нибудь прийти, – договорила Алиса.")
        elif query in graph['Karolineworkoff']:
            print(KarolineClosework())
        elif query == 'прага':
            webbrowser.open(graph['программа'][0])
        elif query == 'калькулятор':
            a = int(input())
            b = int(input())
            print(talk(str(a+b)))
```

# Итоги, дальнейшее развитие
Подведём итоги, после всех наших действий, мы получили простую голосовую помощницу, которая улавливает ключевые слова и выполняет действия, которые стоят за этим словами. Чисто в теории Каролину можно подключить к chatGPT, или другой нейронной сети, такого характера и сделать Каролину более живой. Примерно(условно) это будет работать так, мы будем что-то говорить Каролине, она будет отправлять это сообщение chatGPT, тот выдаёт ответ, Каролина его перенимает и высылает нам: 

>> Каролина, как твои дела ?

-отправляет предложение chatGPT-

-chatGPT даёт ответ, Каролина его копирует-

>> Все хорошо, а у вас как ?

Таким образом Каролину можно оживить, и она будет с нами разговаривать. Понятное дело, что для этого надо разобраться с библиотеками, которые работают с токенами и так далее. 

Но это в будущем. 

## Примечание
Полный код
```

graph = {}
graph['интернет'] = ['web', 'map', 'инет', 'паутина']
graph['allMAcBookAppsEng'] = ['открой skype', 'откройка steam', 'open skype', 'open steam']
graph['Karolineworkoff'] = ['закройся', 'stop', 'exit', 'пока', 'bye', 'off', 'стоп']
graph['KarolineMusic'] = ['music', 'музыка', 'melody', 'мелодия']
graph['clock'] = ['clock', 'time', 'alarm', 'покажи время', 'минуты', 'секунды']
graph['программа'] = ['https://www.youtube.com/watch?v=SW_UCzFO7X0', 'часы']
allMAcBookAppsEng = ['skype', 'steam', 'zoom', 'freeform', 'discord', 'google chrome', 'miro', 'tv', 'blender']

    with speech_recognition.Microphone() as mic:
        print('Говорите')
        sr.pause_threshold = 1
        sr.adjust_for_ambient_noise(source=mic, duration=1)
        audio = sr.listen(source=mic)
        try:
            query = sr.recognize_google(audio, language='ru').lower()
            print('вы сказали:' + query)
        except speech_recognition.UnknownValueError:
            print('(\(\ ')
            print('(=0:0)')
            print( '(..(")(")')
        if 'try' in query:
            talk('Отлично')
        elif query == 'hello':
            print(KarolineHello())
        elif query in allMAcBookAppsEng or query in graph['allMAcBookAppsEng']:
            print(KarolineOpenApp())
            open(query)
        elif query in graph['интернет']:
            talk('Начинаем серфить интернет')
            url = 'https://www.google.com/?client=safari&channel=iphone_bm'
            webbrowser.open(url)
        elif query in graph['clock']:
            talk('Время не любит, когда его убивают' + query)
            url = 'https://time100.ru/Saint-Petersburg'
            webbrowser.open(url)
        elif query in graph['KarolineMusic']:
            talk('Открываю вашу волну')
            webbrowser.open('https://vk.com/audios371153804')
        elif query in 'сказка':
            talk("Не знаете ли вы, как мне выйти отсюда? – Это зависит от того, куда ты хочешь прийти, – ответил Кот. – Мне все равно, куда бы ни… – начала Алиса. – Значит, тебе все равно, в какую сторону идти, – перебил ее Кот. – Куда бы ни выйти, лишь бы куда-нибудь прийти, – договорила Алиса.")
        elif query in graph['Karolineworkoff']:
            print(KarolineClosework())
        elif query == 'прага':
            webbrowser.open(graph['программа'][0])
        elif query == 'калькулятор':
            a = int(input())
            b = int(input())
            print(talk(str(a+b)))

```
