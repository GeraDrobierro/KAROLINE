### KAROLINE

# ВСТУПЛЕНИЕ
Вся моя работа над вопросно-ответной системой 'KAROLINE' началась с комадны `say`, введеной в терминал, которая заставила мой компьютер возпроизвести последующую за ней строку `Hello my friend`

Далее в python, я написал простенький код, чтобы проверить одну теорию:

```
import os
a = str(input())
If a == “привет”
print(os.system(‘say ‘ + ‘привет, меня зовут Каролина’))
```

И вот оно. В первый раз заговорили с женским полом, шучу. Этот код позволил убедиться в следующей теории. Я ввёл некую ключевую команду строчного типа, а потом сделал так, чтобы на этот ключ реагировала наша программа, и это сработало. Из всего этого следует, что я могу задать n-количество ключевых команд, и Каролина будет на них реагировать.

Но мы хотим, чтобы она сумела не только говорить с нами, мы хотим, чтобы она нас слушала, выполняла различные команды. И таким образом, я плавно перехожу к следующему пункту, а именно оставлению блок-схемы или roadmap Каролины.

# ROADMAP

![здесь должна быть  roadmap, но разработчик ушел кушать](https://github.com/GeraDrobierro/KAROLINE/files/12868733/ROADMAP.pdf)


В каждом блоке или квадратике, как вам угодно, написана задача, которую должна выполнять Каролина. С помощью лучшего изобретения человечества(интернет) и некоторых знаний, стрелочками вне блоков я написал решение этих задача.

## библиотеки
Из поставленных в roadmap задач для того, чтобы создать мою Каролину мне нужно было что-то, что могло бы слышать мою речь и переводить ее в строку. Для этого, благо, на Python существует библиотека Speech_Recognition. Обо всем ее функционале в полном объёме объясняют [здесь](https://pythonpip.ru/examples/raspoznavanie-rechi-i-golosa-na-python-podrobno#:~:text=Библиотека%20SpeechRecognition%20ведет%20себя%20как,заданное%20распознавание%20речи%20по%20умолчанию.). Мне же нужно было только то, что с помощью этой библиотеки можно записывать речь с микрофона и преобразовать ее в  строчный формат. Далее, модуль [webbrowser](https://docs.python.org/3/library/webbrowser.html), он позволит работать с url ссылками и открывать их. 
Библиотека [AppOpener](https://pypi.org/project/appopener/), данная библиотека позволит работать с приложениями, установленными на моем компьютере. Модуль [sys](https://pythonim.ru/moduli/sys-python) нужен будет в будущем для того, чтобы остановить работу Каролины по ключевому слову. Сейчас самый важный модуль - os. Проследите за логической цепочкой: say является одной из команд операционной системы, python просто так с ним работать не будет, он попросту не понимает что такое say, поэтому нам нужно что-то, что позволяло бы работать с этой командой, и решением этого вопроса станет библиотека [os](https://all-python.ru/osnovy/os.html#chto-takoe-modul-os).

## установка необходимых библиотек


## код

Сначала импортируем необходимый нам библиотеки, чтобы мы могли с ними работать
```
import speech_recognition
import os
import sys
import webbrowser
from AppOpener import open
```
Так, теперь, постоянно прописывать `os.system(‘say ‘ + ‘текст’)` неудобно, долго, муторно и другие негативные прилагательные. Cоздадим функцию, с помощью которой будет говорить Каролина

```
def talk(words):
    print(words)
    os.system("say " + words)
```
Обьяснение кода я передаю своему коллеге, ![proggramist](https://github.com/GeraDrobierro/KAROLINE/files/12893271/CamScanner.13.10.2023.15.04.pdf)



## Хеш-таблица 
Что это и зачем оно нужно ?
Хеш-таблица - это структура данных, которая принимает ключ и передаёт нам значение. Ключ - один, а значений может быть много. Очень удобная вещь в умелых руках. Подробнее о ней рассказал Адитья Бхаргава в своей книге [«Грокаем Алгоритмы».](https://www.klex.ru/1718) Но зачем она мне здесь ? Видите ли, мы с вами говорим по разному, и слово «привет», к примеру, можно сказать как приветус, приветик, приветули. А Каролина должна понимать все эти значения, поэтому хеш таблица, выручит нас в этом. Мы передадим Каролине ключ [‘hello’], и если в значениях по этому ключу будет содержаться какой-либо вариант из выше перечисленного, она поймёт нас и выполнит команду, как только распознаёт это значение в хеш-таблице.

```
graph = {}
graph['интернет'] = ['web', 'map', 'инет', 'паутина']
graph['allMAcBookAppsEng'] = ['открой skype', 'откройка steam', 'open skype', 'open steam']
graph['Karolineworkoff'] = ['закройся', 'stop', 'exit', 'пока', 'bye', 'off', 'стоп']
graph['KarolineMusic'] = ['music', 'музыка', 'melody', 'мелодия']
graph['clock'] = ['clock', 'time', 'alarm', 'покажи время', 'минуты', 'секунды']
graph['программа'] = ['https://www.youtube.com/watch?v=SW_UCzFO7X0', 'часы']
allMAcBookAppsEng = ['skype', 'steam', 'zoom', 'freeform', 'discord', 'google chrome', 'miro', 'tv', 'blender']
```


Если говорить честно, я экспериментировал в хеш-таблице, поэтому в ней реализовано не только разное произношение слов, к примеру, я добавил сюда ключ graph['allMAcBookAppsEng'], чтобы посмотреть сможет ли Каролина распознавать не только команды из одного слова, но и из нескольких, как выяснилось, она может это делать.

Далее я добавил массив, который можно было бы занести в хеш, но я этого не сделал, опять же из за экспериментов с Каролиной. (Прикольно, что теперь я могу оправдать что угодно в коде, сказав, что это был эксперимент ;))

```
allMAcBookAppsEng = ['skype', 'steam', 'zoom', 'freeform', 'discord', 'google chrome', 'miro', 'tv', 'blender']
```

Это все программы моего компьютера на английском языке, чтобы в будущем Каролина проверяла, есть ли такая программа на компьютере, и открывала ее в случае нахождения. С этой частью когда разобрались, идём дальше.

Сейчас мы будем разбираться в следующем блоке кода:

```
with speech_recognition.Microphone() as mic:
    print('Говорите')
    sr.pause_threshold = 1
    sr.adjust_for_ambient_noise(source=mic, duration=1)
    audio = sr.listen(source=mic)
    try:
        query = sr.recognize_google(audio, language='ru').lower()
        print('вы сказали:' + query)
    except speech_recognition.UnknownValueError:
        print('(\(\ ')
        print('(=0:0)')
        print( '(..(")(")')
```

1. `with speech_recognition.Microphone() as mic:` - начинаем прослушивать микрофон. 
Добавляем строку `print(«Говорите»)`, чтобы пользователь понимал, когда Каролина слушает его.

2. `sr.pause_threshold = 1` - здесь мы установили паузы, после которой Каролина будет нас слушать.


Пример:

Каролина >> Говорите

**1 секунда проходит**

Пользователь >> Говорит

Каролина >> Выполняет команду

`sr.adjust_for_ambient_noise(source=mic, duration=1)` - убираем посторонние шумы из аудиодорожки, чтобы Каролина ‘концентрировалась’ на нашем голосе и командах
`audio = sr.listen(source=mic)` - передаем наши записанные данные в переменную **audio**.

3. Теперь самая важная часть кода, без которой ничего не будет работать.
```
   try:
        query = sr.recognize_google(audio, language='ru').lower()
        print('вы сказали:' + query)
    except speech_recognition.UnknownValueError:
        print('(\(\ ')
        print('(=0:0)')
        print( '(..(")(")')
```
Сначала опишу, что происходит внутри кода:
Переменная query распознает данные, которые были записаны в переменную audio, так как поумолчанию распознавание на английском, мы добавили распознавание на русском и еще добавили нижний регистр с помощью .lower() (это - нижний регистр, ЭТО - не нижний регистр)
Потом с помощью `print('вы сказали:' + query)` будет выводиться то, что мы сказали. Но проблема в том, что у распознавания речи есть одна ошибка, которая прекращает работу алгоритма в случае ее возникновения. Это ошибка UnknownValueError - означает, что Каролина не поняла, что мы ей сказали. Это был один из самых важных врагов моего кода. На помощь мне пришла особая конструкция, о которой говорится ниже.

Теперь я расскажу про конструкцию  **try - except**:

Напишите пожалуйста следующий код:
```
print(7/0)

>> ZeroDivisionError: division by zero
```
И что же мы получили ? Ошибку (ZeroDivisionError: division by zero), ведь на ноль делить нельзя, но что, если скажу, что мы можем сделать это не ошибкой.

```
try:
    print(7/0)
except ZeroDivisionError:
    print('ты математически накосячил, но ничего страшного')
```
Теперь вместо `‘ZeroDivisionError: division by zero’`, мы получаем `'ты математически накосячил, но ничего страшного’`. Подробно посмотрим, что произошло:
Я попросил компьютер, чтобы он пытался выполнить print(7/0), но при этом ожидал ошибку ZeroDivisionError и выводил ‘ты математически накосячил, но ничего страшного’. На языке программирования Python в try: мы пишем, что хотим сделать, а в except <название ошибки> : действия в случае этой ошибки.

Вернемся к нашему основному коду
```
   try:
        query = sr.recognize_google(audio, language='ru').lower()
        print('вы сказали:' + query)
    except speech_recognition.UnknownValueError:
        print('(\(\ ')
        print('(=0:0)')
        print( '(..(")(")')
```
Мы передали в **try:**
  **query = sr.recognize_google(audio, language='ru').lower()**
   **print('вы сказали:' + query)**
То есть попросили Каролину, чтобы она распознавала наш голос, но в случае ошибки , попросили ее быть к ней готовой и выводили зайчика:
 **except speech_recognition.UnknownValueError:**
        **print('(\(\ ‘)**
       ** print('(=0:0)’)**
       **print( ‘(..(«)(«)’)**

Для тех, кто хочет ознакомиться с этой констрикцией подробней нажмите на [меня](https://www.youtube.com/watch?v=qjqbek5tG3A&t=643s)
